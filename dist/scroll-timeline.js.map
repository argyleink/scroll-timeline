{"version":3,"file":"scroll-timeline.js","sources":["../src/utils.js","../src/scroll-timeline-base.js","../src/intersection-based-offset.js","../src/index.js"],"sourcesContent":["export function parseLength(str) {\n  let matches = str.trim().match(/^(-?[0-9]*\\.?[0-9]*)(px|%)$/);\n  if (matches) {\n    return {\n      value: matches[1],\n      unit: matches[2],\n    };\n  }\n  return null;\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { parseLength } from \"./utils\";\n\nlet scrollTimelineOptions = new WeakMap();\nlet extensionScrollOffsetFunctions = [];\n\nfunction scrollEventSource(scrollSource) {\n  if (scrollSource === document.scrollingElement) return document;\n  return scrollSource;\n}\n\n/**\n * Updates the currentTime for all Web Animation instanced attached to a ScrollTimeline instance\n * @param scrollTimelineInstance {ScrollTimeline}\n */\nfunction updateInternal(scrollTimelineInstance) {\n  let animations = scrollTimelineOptions.get(scrollTimelineInstance).animations;\n  if (animations.length === 0) return;\n  let currentTime = scrollTimelineInstance.currentTime;\n  for (let i = 0; i < animations.length; i++) {\n    // The web-animations spec says to throw a TypeError if you try to seek to\n    // an unresolved time value from a resolved time value, so to polyfill the\n    // expected behavior we cancel the underlying animation.\n    if (currentTime == null) {\n      if (animations[i].playState === \"paused\") animations[i].cancel();\n    } else {\n      animations[i].currentTime = currentTime;\n    }\n  }\n}\n\n/**\n * Calculates the number of milliseconds mapped to the scroll range in case of \"auto\"\n *  in case developer provided timeRange, we use that directly.\n * @param scrollTimeline {ScrollTimeline}\n * @returns {Number}\n */\nfunction calculateTimeRange(scrollTimeline) {\n  let timeRange = scrollTimeline.timeRange;\n  if (timeRange === \"auto\") {\n    timeRange = 0;\n    let options = scrollTimelineOptions.get(scrollTimeline).animationOptions;\n    for (let i = 0; i < options.length; i++) {\n      timeRange = Math.max(timeRange, calculateTargetEffectEnd(options[i]));\n    }\n    if (timeRange === Infinity) timeRange = 0;\n  }\n  return timeRange;\n}\n\n// TODO: commented as it's currently not being utilized\n// function removeAnimation(scrollTimeline, animation) {\n//   let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n//   let index = animations.indexOf(animation);\n//   if (index === -1) return;\n//   animations.splice(index, 1);\n//   scrollTimelineOptions.get(scrollTimeline).animationOptions.splice(index, 1);\n// }\n\n/**\n * Determines target effect end based on animation duration, iterations count and start and end delays\n *  returned value should always be positive\n * @param options {Object} ScrollTimeline options\n * @returns {number}\n */\nexport function calculateTargetEffectEnd(options) {\n  if (options.iterationCount === Infinity) return Infinity;\n  return Math.max(\n    (options.startDelay || 0) +\n      (options.duration || 0) * (options.iterationCount || 1) +\n      (options.endDelay || 0),\n    0\n  );\n}\n\n/**\n * Enables the usage of custom parser and evaluator function, utilized by intersection based offset.\n * @param parseFunction {Function}\n * @param evaluateFunction {Function}\n * @returns {Array} all currently installed parsers\n */\nexport function installScrollOffsetExtension(parseFunction, evaluateFunction) {\n  extensionScrollOffsetFunctions.push({\n    parse: parseFunction,\n    evaluate: evaluateFunction,\n  });\n  return extensionScrollOffsetFunctions;\n}\n\n/**\n * Calculates scroll offset based on orientation and scrollSource geometry\n * @param scrollSource {DOMElement}\n * @param orientation {String}\n * @returns {number}\n */\nexport function calculateMaxScrollOffset(scrollSource, orientation) {\n  // TODO: Support other writing directions.\n  if (orientation === \"block\") orientation = \"vertical\";\n  else if (orientation === \"inline\") orientation = \"horizontal\";\n  if (orientation === \"vertical\")\n    return scrollSource.scrollHeight - scrollSource.clientHeight;\n  else if (orientation === \"horizontal\")\n    return scrollSource.scrollWidth - scrollSource.clientWidth;\n}\n\nexport function calculateScrollOffset(\n  autoValue,\n  scrollSource,\n  orientation,\n  offset,\n  fn\n) {\n  if (fn)\n    return fn(\n      scrollSource,\n      orientation,\n      offset,\n      autoValue === \"0%\" ? \"start\" : \"end\"\n    );\n  // TODO: Support other writing directions.\n  if (orientation === \"block\") orientation = \"vertical\";\n  else if (orientation === \"inline\") orientation = \"horizontal\";\n\n  let maxValue =\n    orientation === \"vertical\"\n      ? scrollSource.scrollHeight - scrollSource.clientHeight\n      : scrollSource.scrollWidth - scrollSource.clientWidth;\n  let parsed = parseLength(offset === \"auto\" ? autoValue : offset);\n  if (parsed.unit === \"%\") return (parseFloat(parsed.value) * maxValue) / 100;\n  return parseFloat(parsed.value);\n}\n\n/**\n * Attaches a Web Animation instance to ScrollTimeline\n * @param scrollTimeline {ScrollTimeline}\n * @param animation {Animation}\n * @param options {Object}\n */\nexport function addAnimation(scrollTimeline, animation, options) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  let animationOptions = scrollTimelineOptions.get(scrollTimeline)\n    .animationOptions;\n  animations.push(animation);\n  animationOptions.push(options);\n  updateInternal(scrollTimeline);\n}\n\n// TODO: this is a private function used for unit testing add function\nexport function _getStlOptions(scrollTimeline) {\n  return scrollTimelineOptions.get(scrollTimeline);\n}\n\nexport class ScrollTimeline {\n  constructor(options) {\n    scrollTimelineOptions.set(this, {\n      scrollSource: null,\n      orientation: \"block\",\n      startScrollOffset: \"auto\",\n      endScrollOffset: \"auto\",\n      timeRange: \"auto\",\n      fill: \"none\",\n\n      // Internal members\n      animations: [],\n      animationOptions: [],\n    });\n    this.scrollSource =\n      (options && options.scrollSource) || document.scrollingElement;\n    this.orientation = (options && options.orientation) || \"block\";\n    this.startScrollOffset = (options && options.startScrollOffset) || \"auto\";\n    this.endScrollOffset = (options && options.endScrollOffset) || \"auto\";\n    this.timeRange = (options && options.timeRange) || \"auto\";\n    this.fill = (options && options.fill) || \"none\";\n  }\n\n  set scrollSource(element) {\n    if (this.scrollSource)\n      scrollEventSource(this.scrollSource).removeEventListener(\"scroll\", () =>\n        updateInternal(this)\n      );\n    if (!(element instanceof Element)) element = document.scrollingElement;\n    scrollTimelineOptions.get(this).scrollSource = element;\n    scrollEventSource(element).addEventListener(\"scroll\", () =>\n      updateInternal(this)\n    );\n    updateInternal(this);\n  }\n\n  get scrollSource() {\n    return scrollTimelineOptions.get(this).scrollSource;\n  }\n\n  set orientation(orientation) {\n    if (\n      [\"block\", \"inline\", \"horizontal\", \"vertical\"].indexOf(orientation) === -1\n    )\n      orientation = \"block\";\n    scrollTimelineOptions.get(this).orientation = orientation;\n    updateInternal(this);\n  }\n\n  get orientation() {\n    return scrollTimelineOptions.get(this).orientation;\n  }\n\n  set startScrollOffset(offset) {\n    let currentStlOptions = scrollTimelineOptions.get(this);\n    // Allow extensions to override scroll offset calculation.\n    currentStlOptions.startScrollOffsetFunction = null;\n    for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\n      let result = extensionScrollOffsetFunctions[i].parse(offset);\n      if (result !== undefined) {\n        offset = result;\n        currentStlOptions.startScrollOffsetFunction =\n          extensionScrollOffsetFunctions[i].evaluate;\n        break;\n      }\n    }\n    currentStlOptions.startScrollOffset = offset;\n    updateInternal(this);\n  }\n\n  get startScrollOffset() {\n    return scrollTimelineOptions.get(this).startScrollOffset;\n  }\n\n  set endScrollOffset(offset) {\n    // Allow extensions to override scroll offset calculation.\n    scrollTimelineOptions.get(this).endScrollOffsetFunction = null;\n    for (let i = 0; i < extensionScrollOffsetFunctions.length; i++) {\n      let result = extensionScrollOffsetFunctions[i].parse(offset);\n      if (result !== undefined) {\n        offset = result;\n        scrollTimelineOptions.get(this).endScrollOffsetFunction =\n          extensionScrollOffsetFunctions[i].evaluate;\n        break;\n      }\n    }\n    scrollTimelineOptions.get(this).endScrollOffset = offset;\n    updateInternal(this);\n  }\n\n  get endScrollOffset() {\n    return scrollTimelineOptions.get(this).endScrollOffset;\n  }\n\n  set timeRange(offset) {\n    scrollTimelineOptions.get(this).timeRange = offset;\n    updateInternal(this);\n  }\n\n  get timeRange() {\n    return scrollTimelineOptions.get(this).timeRange;\n  }\n\n  get currentTime() {\n    // Per https://wicg.github.io/scroll-animations/#current-time-algorithm\n    // Step 1\n    let unresolved = null;\n    if (!this.scrollSource) return unresolved;\n    let startOffset = calculateScrollOffset(\n      \"0%\",\n      this.scrollSource,\n      this.orientation,\n      this.startScrollOffset,\n      scrollTimelineOptions.get(this).startScrollOffsetFunction\n    );\n    let endOffset = calculateScrollOffset(\n      \"100%\",\n      this.scrollSource,\n      this.orientation,\n      this.endScrollOffset,\n      scrollTimelineOptions.get(this).endScrollOffsetFunction\n    );\n    let timeRange = calculateTimeRange(this);\n\n    // Step 2\n    let currentScrollOffset = this.orientation === 'block'\n      ? this.scrollSource.scrollTop\n      : this.scrollSource.scrollLeft\n\n    // Step 3\n    if (currentScrollOffset < startOffset) {\n      if (this.fill === \"none\" || this.fill === \"forwards\") return unresolved;\n      return 0;\n    }\n\n    // Step 4\n    if (currentScrollOffset >= endOffset) {\n      if (\n        endOffset <\n          calculateMaxScrollOffset(this.scrollSource, this.orientation) &&\n        (this.fill === \"none\" || this.fill === \"backwards\")\n      ) {\n        return unresolved;\n      }\n      return timeRange;\n    }\n\n    // Step 5\n    return (\n      ((currentScrollOffset - startOffset) / (endOffset - startOffset)) *\n      timeRange\n    );\n  }\n\n  get __polyfill() {\n    return true;\n  }\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { parseLength } from \"./utils\";\n\nlet IntersectionOptions = new WeakMap();\n\n// Margin is stored as a 4 element array [top, right, bottom, left] but can be\n// specified using anywhere from 1 - 4 elements. This map defines how to convert\n// various length inputs to their components.\nconst TOP = 0;\nconst RIGHT = 1;\nconst BOTTOM = 2;\nconst LEFT = 3;\nconst MARGIN_MAP = [\n  // 1 length maps to all positions.\n  [[TOP, RIGHT, BOTTOM, LEFT]],\n  // 2 lengths maps to vertical and horizontal margins.\n  [\n    [TOP, BOTTOM],\n    [RIGHT, LEFT],\n  ],\n  // 3 lengths maps to top, horizontal, bottom margins.\n  [[TOP], [RIGHT, LEFT], [BOTTOM]],\n  // 4 lengths maps to each component.\n  [[TOP], [RIGHT], [BOTTOM], [LEFT]],\n];\n\nclass IntersectionBasedOffset {\n  constructor(value) {\n    IntersectionOptions.set(this, {\n      target: null,\n      edge: \"start\",\n      threshold: 0,\n      rootMargin: [\n        [0, \"px\"],\n        [0, \"px\"],\n        [0, \"px\"],\n        [0, \"px\"],\n      ],\n    });\n    this.target = value.target;\n    this.edge = value.edge || \"start\";\n    this.threshold = value.threshold || 0;\n    this.rootMargin = value.rootMargin || \"0px 0px 0px 0px\";\n    this.clamp = value.clamp || false;\n  }\n\n  set target(element) {\n    if (!(element instanceof Element)) {\n      IntersectionOptions.get(this).target = null;\n      throw Error(\"Intersection target must be an element.\");\n    }\n    IntersectionOptions.get(this).target = element;\n  }\n\n  get target() {\n    return IntersectionOptions.get(this).target;\n  }\n\n  set edge(value) {\n    if ([\"start\", \"end\"].indexOf(value) == -1) return;\n    IntersectionOptions.get(this).edge = value;\n  }\n\n  get edge() {\n    return IntersectionOptions.get(this).edge;\n  }\n\n  set threshold(value) {\n    let threshold = parseFloat(value);\n    // Throw a RangeError for out of range threshold:\n    // https://w3c.github.io/IntersectionObserver/#intersection-observer-interface\n    if (threshold < 0 || threshold > 1)\n      throw RangeError(\"threshold must be in the range [0, 1]\");\n    IntersectionOptions.get(this).threshold = threshold;\n  }\n\n  get threshold() {\n    return IntersectionOptions.get(this).threshold;\n  }\n\n  set rootMargin(value) {\n    let margins = value.split(/ +/);\n    if (margins.length < 1 || margins.length > 4)\n      throw TypeError(\n        \"rootMargin must contain between 1 and 4 length components\"\n      );\n    let parsedMargins = [[], [], [], []];\n    for (let i = 0; i < margins.length; i++) {\n      let parsedValue = parseLength(margins[i]);\n      if (!parsedValue) throw TypeError(\"Unrecognized rootMargin length\");\n      let positions = MARGIN_MAP[margins.length - 1][i];\n      for (let j = 0; j < positions.length; j++) {\n        parsedMargins[positions[j]] = [\n          parseFloat(parsedValue.value),\n          parsedValue.unit,\n        ];\n      }\n    }\n    IntersectionOptions.get(this).rootMargin = parsedMargins;\n  }\n\n  get rootMargin() {\n    // TODO: Simplify to the shortest matching specification for the given margins.\n    return IntersectionOptions.get(this)\n      .rootMargin.map((margin) => {\n        return margin.join(\"\");\n      })\n      .join(\" \");\n  }\n\n  set clamp(value) {\n    // This is just for testing alternative proposals - not intended to be part\n    // of the specification.\n    IntersectionOptions.get(this).clamp = !!value;\n  }\n}\n\nexport function parseOffset(value) {\n  if (value.target) return new IntersectionBasedOffset(value);\n}\n\nfunction resolveLength(length, containerSize) {\n  if (length[1] == \"%\") return (length[0] * containerSize) / 100;\n  // Assumption is only px or % will be passed in.\n  // TODO: Support other length types (e.g. em, vh, etc).\n  return length[0];\n}\n\nexport function calculateOffset(scrollSource, orientation, offset, startOrEnd) {\n  // TODO: Support other writing directions.\n  if (orientation == \"block\") orientation = \"vertical\";\n  else if (orientation == \"inline\") orientation = \"horizontal\";\n  let originalViewport =\n    scrollSource == document.scrollingElement\n      ? {\n          left: 0,\n          right: scrollSource.clientWidth,\n          top: 0,\n          bottom: scrollSource.clientHeight,\n          width: scrollSource.clientWidth,\n          height: scrollSource.clientHeight,\n        }\n      : scrollSource.getBoundingClientRect();\n\n  // Resolve margins and offset viewport.\n  let parsedMargins = IntersectionOptions.get(offset).rootMargin;\n  let computedMargins = [];\n  for (let i = 0; i < 4; i++) {\n    computedMargins.push(\n      resolveLength(\n        parsedMargins[i],\n        i % 2 == 0 ? originalViewport.height : originalViewport.width\n      )\n    );\n  }\n  let viewport = {\n    left: originalViewport.left - computedMargins[LEFT],\n    right: originalViewport.right + computedMargins[RIGHT],\n    width:\n      originalViewport.right -\n      originalViewport.left +\n      computedMargins[LEFT] +\n      computedMargins[RIGHT],\n    top: originalViewport.top - computedMargins[TOP],\n    bottom: originalViewport.bottom + computedMargins[BOTTOM],\n    height:\n      originalViewport.bottom -\n      originalViewport.top +\n      computedMargins[TOP] +\n      computedMargins[BOTTOM],\n  };\n\n  let clamped = IntersectionOptions.get(offset).clamp;\n  let target = offset.target.getBoundingClientRect();\n  let threshold = offset.threshold;\n  // Invert threshold for start position.\n  if (offset.edge == \"start\") threshold = 1 - threshold;\n  // Projected point into the scroller scroll range.\n  if (orientation == \"vertical\") {\n    let point =\n      target.top +\n      target.height * threshold -\n      viewport.top +\n      scrollSource.scrollTop;\n    if (clamped) {\n      if (offset.edge == \"end\") return Math.max(0, point - viewport.height);\n      return Math.min(point, scrollSource.scrollHeight - viewport.height);\n    } else {\n      if (offset.edge == \"end\") return point - viewport.height;\n      return point;\n    }\n  } else {\n    // orientation == 'horizontal'\n    let point =\n      target.left +\n      target.width * threshold -\n      viewport.left +\n      scrollSource.scrollLeft;\n    if (clamped) {\n      if (offset.edge == \"end\") return Math.max(0, point - viewport.width);\n      return Math.min(point, scrollSource.scrollWidth - viewport.width);\n    } else {\n      if (offset.edge == \"end\") return point - viewport.width;\n      return point;\n    }\n  }\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {\n  ScrollTimeline,\n  installScrollOffsetExtension,\n  addAnimation,\n} from \"./scroll-timeline-base\";\nimport { calculateOffset, parseOffset } from \"./intersection-based-offset\";\n\nconst nativeElementAnimate = window.Element.prototype.animate;\n\n/**\n * Decides whether to use native Element.prototype.animate function in regular fashion or pass it to our polyfill\n *  so its current time is driven by scroll event\n * @param keyframes {Object} array of keyframe objects\n * @param options {Object} WAAPI options object\n * @returns {Function}\n */\n\nconst animate = function (keyframes, options) {\n  let timeline = options.timeline;\n  if (!timeline || !(timeline instanceof ScrollTimeline)) {\n    return nativeElementAnimate.apply(this, [keyframes, options]);\n  }\n  delete options.timeline;\n  let animation = nativeElementAnimate.apply(this, [keyframes, options]);\n  // TODO: Create a proxy for the animation to control and fake the animation\n  // play state.\n  animation.pause();\n  addAnimation(timeline, animation, options);\n  return animation;\n};\n\ninstallScrollOffsetExtension(parseOffset, calculateOffset);\nif (\n  !Reflect.defineProperty(window, \"ScrollTimeline\", { value: ScrollTimeline })\n) {\n  throw Error(\n    \"Error installing ScrollTimeline polyfill: could not attach ScrollTimeline to window\"\n  );\n}\n\nif (!Reflect.defineProperty(Element.prototype, \"animate\", { value: animate })) {\n  throw Error(\n    \"Error installing ScrollTimeline polyfill: could not attach WAAPI's animate to DOM Element\"\n  );\n}\n"],"names":["parseLength","str","matches","trim","match","value","unit","scrollTimelineOptions","WeakMap","extensionScrollOffsetFunctions","scrollEventSource","scrollSource","document","scrollingElement","updateInternal","scrollTimelineInstance","animations","get","length","currentTime","i","playState","cancel","calculateTargetEffectEnd","options","Infinity","iterationCount","Math","max","startDelay","duration","endDelay","calculateScrollOffset","autoValue","orientation","offset","fn","maxValue","scrollHeight","clientHeight","scrollWidth","clientWidth","parsed","parseFloat","ScrollTimeline","set","this","startScrollOffset","endScrollOffset","timeRange","fill","animationOptions","_createClass","element","removeEventListener","_this","Element","addEventListener","indexOf","currentStlOptions","startScrollOffsetFunction","result","parse","undefined","evaluate","endScrollOffsetFunction","startOffset","endOffset","scrollTimeline","calculateTimeRange","currentScrollOffset","scrollTop","scrollLeft","IntersectionOptions","MARGIN_MAP","IntersectionBasedOffset","target","edge","threshold","rootMargin","clamp","Error","RangeError","margins","split","TypeError","parsedMargins","parsedValue","positions","j","map","margin","join","nativeElementAnimate","window","prototype","animate","push","startOrEnd","originalViewport","left","right","top","bottom","width","height","getBoundingClientRect","computedMargins","viewport","clamped","point","min","Reflect","defineProperty","keyframes","timeline","apply","animation","pause","addAnimation"],"mappings":"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"}